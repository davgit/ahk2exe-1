
///////////////////////////////////////////////////////////////////////////////
//
// AutoIt
//
// Copyright (C)1999-2003:
//		- Jonathan Bennett <jon@hiddensoft.com>
//		- See "AUTHORS.txt" for contributors.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
///////////////////////////////////////////////////////////////////////////////
//
// token_datatype.cpp
//
// The class for a token datatype (requires variant_datatype).
// Functions are called via operator overloading!
//
///////////////////////////////////////////////////////////////////////////////


// Includes
#include "StdAfx.h"								// Pre-compiled headers

#ifndef _MSC_VER								// Includes for non-MS compilers
//	#include <stdio.h>
//	#include <stdlib.h>
//	#include <string.h>
#endif

#include "token_datatype.h"


///////////////////////////////////////////////////////////////////////////////
// Constructor()
///////////////////////////////////////////////////////////////////////////////

Token::Token()
{

} // Token()


///////////////////////////////////////////////////////////////////////////////
// Copy Constructor
///////////////////////////////////////////////////////////////////////////////

Token::Token(const Token &vOp2)
{
	m_nType		= vOp2.m_nType;
	m_Variant	= vOp2.m_Variant;
	m_nCol		= vOp2.m_nCol;
}


///////////////////////////////////////////////////////////////////////////////
// Destructor()
///////////////////////////////////////////////////////////////////////////////

Token::~Token()
{
} // ~Token()


///////////////////////////////////////////////////////////////////////////////
// Overloaded operator=() for tokens
///////////////////////////////////////////////////////////////////////////////

Token& Token::operator=(const Token &vOp2)
{
	if (this != &vOp2)
	{
		m_nType		= vOp2.m_nType;
		m_Variant	= vOp2.m_Variant;
		m_nCol		= vOp2.m_nCol;
	}

	return *this;								// Return this object that generated the call

} // operator=()
